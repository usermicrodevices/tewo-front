## Настройка и использование VSCode

В проекте уже есть все конфигурационные файлы, давайте использовать общие на всех. Что-то для себя можно включить в настройках приложения или предложить включить всем.

### Расширения для vscode
* msjsdiag.debugger-for-chrome - Чтобы работал дебагер хрома
* editorconfig.editorconfig - Чтобы подгрузилась настройка пробелов/отступов

### Запуск отладчика Пишем в консоль npm start
* Переходим во вкладку Run или жмём ctrl+shift+d
* Жмём зелёную кнопку play. Запустится отдельное окно хрома, не склеиваемое с остальными окнами (нельзя открыть как вкладку), в нём будут грузится сорсмапы

## Структура кода и архитектура приложения
### Файловая структура
В src 7 папок и роутеры:

* compnents - для компонентов, касающихся специфики проекта, имплеменирующих конкретный модуль. Компоненты вызываются страницами и другими компонентами один раз, редко два
* models - модели. Модели отвечают за состояние компонентов, подрузку данных с сервера
* services - прослойка между моделями и api. Унифицирует используемые эндпоинты, добавляет возможность мокать не готовые к тестированию эндпоинты. Модели получают данные от сервисов, сервисы не порождают модели
* pages - страницы, описывающие макрокод, определяющий внешний вид страницы. Каждый компонент, описанный в pages соответствует уникальному url, страницы используются только роутерами, роутеры используют только страницы
* utils - Логически обособенные функции, выполняющие задачи, не касающиеся конкретного проекта
* elements - Логически обособленные компоненты, не использующие модели и не специфичные для проекта
* themes - глобальные настройки стилей, константы стилей, настройка antd, шрифты
* Роутеры - cуществует два роутера: RootRouter, определяющий маршрутизацию до авторизации и AuthorizedRouter, определяющий маршрутизацию когда авторизация пройдена

Наряду с ними есть config.js для доступа к переменным окружения

### Работа с константами
Все константы, касающиеся всего приложения в целом должны быть заданы на уровне переменных окружения и доступ к ним должен осуществляться через config.js, все переменные уровня компонента или модели должны быть определены на уровне данного компонента или модели

### Система инстанцирования моделей и буферизация
Любая модель принадлежит какому-то компоненту либо модели. Модель должна инстанцироваться настолько поздно насколько это возможно и принадлежать самому глубокому компоненту, охватывающему компоненты, использующие модель. Модель авторизации принадлежит authorizedRouter и инстанцируется в нём. Все данные пользователя хранятся в auth, включая любые кешируемые данные. Такой подход позволяет гарантировать полную очистку всех пользовательских данных в случае logout. Любые кешируемые данные хранятся в модели auth, время жизни любого кеша на данном этапе развития проекта ограничено временем существования вкладки бразуера. Это ставит разумное ограничение на сложность отладки.
Такой подход позволяет решить распространённую проблему и скорцентрировать ответственность в одном конкретном элементе. Ошибка заключается в том, что не все кешируемые данные очищаются при авторизации от лица другого пользователя и пользователю видны данные, доступные пользователю, работавшему на данном устройстве ранее. Описанный подход опирается на то, что создание объекта, хранящего кешируемые данные привязано к факту авторизации через факт монтирования компонента, управляющего работой авторизованного пользователя.

### Разработка компонентов, осуществляющих изменение данных с сервера
Любые изменения данных, загружаемых в модели с сервера должны осуществляться транзакционно. Например, если мы разрабатываем компонент, осуществляющий изменение пользовательских данных то для компонента, определяющего интерфейс редактора должна создаваться копия модели пользователя и все изменения должны осщуествляться в этой копии и при нажатии "сохранить" изменённые данные должны передаваться модели, управляющей загруженными данными пользователя, эта модель должна выслать данные на сервер и после получения сообщения об успешном получении данных сервером должна изменять данные пользователя внутри себя. Недопустим прямой доступ полей ввода и других редактирующих компонентов в модели, хранящие данные, загруженные с сервера.
#### Правильно
```js
import React from 'react';
import { inject, observer } from 'mobx-react';

import UserEditor from 'components/userEditor';

@inject('users')
@observer
class UserEditorPage extends React.Component {
  state = { edditing: null };

  componentDidMount() {
    this.setState{ edditing: this.props.users[this.props.id].clone() });
  }

  onCommit = () => {
    this.props.users.updateUser(this.state.edditing);
  }

  render() {
  	const { edditing } = this.state
    return (
	  <UserEditor data={edditing} onCommit={this.onCommit} />
	);
  }
}

export default UserEditorPage;
```
#### Не правильно
```js
import React from 'react';
import { inject, observer } from 'mobx-react';

import UserEditor from 'components/userEditor';

@inject('users')
@observer
class UserEditorPage extends React.Component {
  onCommit = () => {
    this.props.users.updateUser(edditing: this.props.users[this.props.id]);
  }

  render() {
  	const data = this.props.users[this.props.id];
    return (
	  <UserEditor data={data} onCommit={this.onCommit} />
	);
  }
}

export default UserEditorPage;
```
### Получение данных
Для контроля получаемых данных используется utils/dataCheck, компонент принимает список ожидаемых данных и сыпет в консоль error если с ними что-то не так. В проде это должно приводить к появлению error, в дебаге к оишбке загрузке данных. Этот механизм создан для того, чтобы разработчик максимально рано узнавал о том, что api изменилось

### Асинхронная подгрузка
Одной из ключевых особенностей проекта является использование асинхронной модели подгрузки данных. Существует два подхода к обработке данных, зависящих от числа записей в соответствующей таблице:

1.  Если данных не много (переменная окружения `REACT_ADD_SMALL_DATA_LIMIT`) данные выгружаются полностью, сортировка, фильтрация и поиск осуществляются на стороне клиента
2.  Если данных много, то данные выгружаются постранично, к данным и интерфейсу предъявляются дополнительные требования:
    1.  Доступна сортировка только по убыванию времени
    2.  Данные могут добавляться только "свежее" чем все существующие

    При выполннии этих требований становится возможным получение новых записей и добавление из в начало кеша по таймеру

### Используемый стек технологий
* [React](https://reactjs.org/)
* [Create React App](https://github.com/facebook/create-react-app)
* [mobx](https://mobx.js.org/) используется в качестве state manager вместо redux
* [sass](https://sass-lang.com/)
* [antd](https://ant.design/) используется в качестве gui-ферймворка
* [React Helmet](https://www.npmjs.com/package/react-helmet) для управления заголовком страницы
* [react-window](https://github.com/bvaughn/react-window) для отображения больших таблиц
* [apexcharts](https://apexcharts.com/) - наши графики
* [eva-icons](https://akveo.github.io/eva-icons/)


### Некоторые вещи, которых вы, возможно, не знаете
* В [CRA](https://create-react-app.dev/) проектах в именах .scss [нужно писать .module](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/)
* config-overrides.js - файл, с помощью которого модуль [customize-cra](https://github.com/arackaf/customize-cra) кастомизирует конфиг вебпака внутри [CRA](https://create-react-app.dev/)
* [customize-cra](https://github.com/arackaf/customize-cra) используется сразу для двух вещей: для включения декораторов и для настройки темы [antd](https://ant.design/)
* less, less-loader и babel-plugin-import нужны только чтобы с помощью [customize-cra](https://github.com/arackaf/customize-cra) определить переменные темы для [antd](https://ant.design/), в остальном проекте они не используются
* Table из antd полностью не используется из-за того, что компонент принимает на себя обработку data что приводит к разделению логики между моделями и antd
* На проекте все важные иконки (меню, кнопки редактирования) берутся из [eva-icons](https://akveo.github.io/eva-icons/), используйте их, если они уместны. Это деляется для того, чтобы иконки в мобильной части приложения были такими же. Для второстепенных иконок (лоадер, префиксы в полях ввода) допускается брать из [antd](https://ant.design/components/icon/)
